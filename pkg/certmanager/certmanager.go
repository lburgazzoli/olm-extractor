// Package certmanager configures cert-manager CA injection for operator admission webhooks.
//
// When extracting OLM bundles that include admission webhooks (ValidatingWebhookConfiguration,
// MutatingWebhookConfiguration), this package automatically:
//  1. Discovers the webhook certificate secret names from deployment volumes
//  2. Creates cert-manager Certificate resources with the correct secret names
//  3. Adds cert-manager.io/inject-ca-from annotations to webhook configurations
//  4. Ensures backing services exist for webhooks
//
// Key Concepts:
//
// Service Name Derivation: Webhook service names follow the pattern "<deployment-name>-service".
// The deployment name is extracted by removing the "-service" suffix.
//
// Secret Name Extraction: Instead of generating generic secret names, this package inspects
// deployment volumes to find the actual secret name the deployment expects. This ensures
// cert-manager creates certificates with names that match the deployment's volume mounts.
//
// Fallback Behavior: If a deployment cannot be found or has no secret volumes, the package
// falls back to generating a name using the pattern "<service-name>-tls".
//
// Integration with operator-framework: This package works with resources generated by OLM's
// resolver.RBACForClusterServiceVersion() and manifests extracted from operator bundles.
package certmanager

import (
	"fmt"
	"strings"

	certmanagerv1 "github.com/cert-manager/cert-manager/pkg/apis/certmanager/v1"
	cmmeta "github.com/cert-manager/cert-manager/pkg/apis/meta/v1"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	"github.com/lburgazzoli/olm-extractor/pkg/kube"
	"github.com/lburgazzoli/olm-extractor/pkg/kube/gvks"
)

const (
	// webhookServiceSuffix is the conventional suffix for webhook service names.
	webhookServiceSuffix = "-webhook-service"

	// certNameSuffix is appended to service names to create certificate names.
	certNameSuffix = "-cert"

	// tlsSecretSuffix is appended to service names to create TLS secret names.
	tlsSecretSuffix = "-tls"

	// selfsignedIssuerSuffix is appended to operator names for auto-generated issuers.
	selfsignedIssuerSuffix = "-selfsigned"

	// expectedObjectsPerWebhook is the estimated number of objects generated per webhook
	// (webhook + certificate + service).
	expectedObjectsPerWebhook = 3
)

// Config holds configuration for cert-manager integration.
type Config struct {
	Enabled    bool   `mapstructure:"cert-manager-enabled"`
	IssuerName string `mapstructure:"cert-manager-issuer-name"`
	IssuerKind string `mapstructure:"cert-manager-issuer-kind"`
}

// Configure analyzes filtered resources and configures cert-manager CA injection for webhooks.
//
// This is the main entry point for cert-manager integration. It processes webhook configurations
// and generates the necessary cert-manager resources and service objects.
//
// Processing Flow:
//  1. Find all webhook configurations (ValidatingWebhookConfiguration, MutatingWebhookConfiguration)
//  2. Determine issuer configuration (auto-generate or use explicit)
//  3. For each webhook, extract the service name from clientConfig.service
//  4. Derive the deployment name from the service name (remove "-service" suffix)
//  5. Extract the actual webhook secret name from the deployment's volumes
//  6. Create a cert-manager Certificate resource with the discovered secret name
//  7. Add cert-manager.io/inject-ca-from annotation to the webhook configuration
//  8. Ensure the webhook service exists (or create it from deployment info)
//  9. Deduplicate services that are shared by multiple webhooks
//
// Auto-Generation: When IssuerName and IssuerKind are empty, automatically creates a
// namespace-scoped self-signed Issuer named "<operator-name>-selfsigned".
//
// Service Deduplication: Multiple webhooks may reference the same service (e.g., multiple
// webhook types handled by the same deployment). The processedServiceNames map ensures
// each service is only added once to the result.
//
// Returns a new slice of objects with webhooks configured, certificates created, and
// services ensured. Non-webhook objects are included unchanged at the end.
func Configure(objects []*unstructured.Unstructured, namespace string, cfg Config) ([]*unstructured.Unstructured, error) {
	webhooks := kube.Find(objects, kube.IsWebhookConfiguration)
	if len(webhooks) == 0 {
		return objects, nil
	}

	// Determine issuer configuration
	issuerName := cfg.IssuerName
	issuerKind := cfg.IssuerKind
	var selfSignedIssuer *unstructured.Unstructured

	// Auto-generate self-signed issuer if not explicitly configured
	if issuerName == "" || issuerKind == "" {
		operatorName := extractOperatorName(objects)
		issuerName = operatorName + selfsignedIssuerSuffix
		issuerKind = "Issuer"

		var err error
		selfSignedIssuer, err = createSelfSignedIssuer(issuerName, namespace)
		if err != nil {
			return nil, fmt.Errorf("failed to create self-signed issuer: %w", err)
		}
	}

	// Process all webhooks and their services
	webhookObjects, processedServiceNames, err := processWebhooks(objects, webhooks, namespace, issuerName, issuerKind)
	if err != nil {
		return nil, err
	}

	// Prepend self-signed issuer if generated
	if selfSignedIssuer != nil {
		webhookObjects = append([]*unstructured.Unstructured{selfSignedIssuer}, webhookObjects...)
	}

	// Add remaining non-webhook objects (excluding processed services)
	remainingObjects := kube.Find(objects, func(obj *unstructured.Unstructured) bool {
		if kube.IsWebhookConfiguration(obj) {
			return false
		}
		if kube.IsKind(obj, gvks.Service) && processedServiceNames[obj.GetName()] {
			return false
		}

		return true
	})

	return append(webhookObjects, remainingObjects...), nil
}

// extractOperatorName determines the operator/bundle name from the objects.
// Uses the same logic as resource normalization:
//  1. First deployment name found
//  2. First service account name found
//  3. Fallback to "operator"
func extractOperatorName(objects []*unstructured.Unstructured) string {
	// Try deployment first
	deployments := kube.Find(objects, func(obj *unstructured.Unstructured) bool {
		return kube.IsKind(obj, gvks.Deployment)
	})
	if len(deployments) > 0 {
		return deployments[0].GetName()
	}

	// Try service account second
	serviceAccounts := kube.Find(objects, func(obj *unstructured.Unstructured) bool {
		return kube.IsKind(obj, gvks.ServiceAccount)
	})
	if len(serviceAccounts) > 0 {
		return serviceAccounts[0].GetName()
	}

	// Fallback
	return "operator"
}

// createSelfSignedIssuer creates a namespace-scoped self-signed Issuer.
func createSelfSignedIssuer(name string, namespace string) (*unstructured.Unstructured, error) {
	issuer := &certmanagerv1.Issuer{
		TypeMeta: metav1.TypeMeta{
			APIVersion: gvks.Issuer.GroupVersion().String(),
			Kind:       gvks.Issuer.Kind,
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      name,
			Namespace: namespace,
		},
		Spec: certmanagerv1.IssuerSpec{
			IssuerConfig: certmanagerv1.IssuerConfig{
				SelfSigned: &certmanagerv1.SelfSignedIssuer{},
			},
		},
	}

	u, err := kube.ToUnstructured(issuer)
	if err != nil {
		return nil, fmt.Errorf("failed to convert issuer to unstructured: %w", err)
	}

	return u, nil
}

// processWebhooks handles webhook processing and returns the configured webhook objects.
//
// This function implements the three-phase approach for webhook configuration:
//
// Phase 1: Extract Deployment Name
//   - Service names follow the pattern "<deployment-name>-service"
//   - Extract deployment name by removing the "-service" suffix
//
// Phase 2: Find Secret Name
//   - Call extractWebhookSecretName() to inspect the deployment's volumes
//   - Use keyword matching to select the most likely webhook certificate secret
//   - Fall back to generated name if deployment not found
//
// Phase 3: Create Certificate
//   - Generate cert-manager Certificate with the discovered secret name
//   - Add cert-manager.io/inject-ca-from annotation to webhook
//   - Ensure the backing service exists (create if needed, update port if needed)
//
// Service Deduplication: Multiple webhooks may share the same service. The processedServices
// map tracks which services have already been added to prevent duplicates in the output.
//
// Returns the webhook objects and a map of processed service names.
func processWebhooks(
	objects []*unstructured.Unstructured,
	webhooks []*unstructured.Unstructured,
	namespace string,
	issuerName string,
	issuerKind string,
) ([]*unstructured.Unstructured, map[string]bool, error) {
	result := make([]*unstructured.Unstructured, 0, len(webhooks)*expectedObjectsPerWebhook)
	processedServices := make(map[string]bool)

	for _, obj := range webhooks {
		info := kube.ExtractWebhookServiceInfo(obj)
		if info == nil {
			result = append(result, obj)

			continue
		}

		// Extract deployment name from service name (remove -service suffix)
		// Webhook services follow the pattern: <deployment-name>-service
		deploymentName := info.ServiceName
		serviceSuffix := "-service"
		if len(info.ServiceName) > len(serviceSuffix) &&
			info.ServiceName[len(info.ServiceName)-len(serviceSuffix):] == serviceSuffix {
			deploymentName = info.ServiceName[:len(info.ServiceName)-len(serviceSuffix)]
		}

		// Extract the actual webhook secret name from the deployment
		secretName := extractWebhookSecretName(objects, deploymentName)
		if secretName == "" {
			// Fallback to generated name if not found in deployment
			secretName = info.ServiceName + tlsSecretSuffix
		}

		// Create Certificate and configure webhook
		certName := info.ServiceName + certNameSuffix

		// Check if certificate already added
		if !hasCertificate(result, certName) {
			cert, err := createCertificate(certName, info.ServiceName, namespace, secretName, issuerName, issuerKind)
			if err != nil {
				return nil, nil, fmt.Errorf("failed to create certificate %s: %w", certName, err)
			}
			result = append(result, cert)
		}

		// Add cert-manager annotation to webhook
		annotationValue := namespace + "/" + certName
		kube.SetAnnotation(obj, certmanagerv1.WantInjectAnnotation, annotationValue)
		result = append(result, obj)

		// Ensure service exists (only add once if shared by multiple webhooks)
		if !processedServices[info.ServiceName] {
			services, err := kube.EnsureService(objects, info.ServiceName, namespace, info.Port, webhookServiceSuffix)
			if err != nil {
				return nil, nil, fmt.Errorf("failed to ensure service %s for webhook %s: %w", info.ServiceName, obj.GetName(), err)
			}

			result = append(result, services...)
			processedServices[info.ServiceName] = true
		}
	}

	return result, processedServices, nil
}

// extractWebhookSecretName extracts the webhook TLS secret name from a deployment's volumes.
//
// This function inspects the deployment's pod spec to find the actual secret that will be
// used for webhook certificates. This is critical because:
//  1. Deployments reference specific secret names in their volume mounts
//  2. cert-manager Certificate resources must create secrets with matching names
//  3. Different operators may use different naming conventions
//
// Resolution Strategy:
//  1. Find the deployment by name (derived from webhook service name)
//  2. Extract all secret volumes from the deployment's pod template spec
//  3. Collect all secrets (name and volume name)
//  4. Call selectWebhookSecret() to choose the best match using keyword heuristics
//  5. Return the selected secret name, or empty string if not found
//
// Why Deployment-Based: The deployment is the source of truth for what secrets are actually
// used. This approach is generic across all OLM bundles, regardless of their naming conventions.
//
// Returns empty string if the deployment cannot be found or has no secret volumes.
func extractWebhookSecretName(objects []*unstructured.Unstructured, deploymentName string) string {
	for _, obj := range objects {
		if !kube.Is(obj, gvks.Deployment, deploymentName) {
			continue
		}

		// Extract volumes from deployment spec
		volumes, found, err := unstructured.NestedSlice(obj.Object, "spec", "template", "spec", "volumes")
		if err != nil || !found {
			continue
		}

		var secretVolumes []secretVolumeInfo

		// Collect all secret volumes
		for _, vol := range volumes {
			volumeMap, ok := vol.(map[string]any)
			if !ok {
				continue
			}

			// Check if this volume has a secret
			secretMap, found, err := unstructured.NestedMap(volumeMap, "secret")
			if err != nil || !found {
				continue
			}

			// Get the secret name and volume name
			secretName, found, err := unstructured.NestedString(secretMap, "secretName")
			if err != nil || !found || secretName == "" {
				continue
			}

			volumeName, _, _ := unstructured.NestedString(volumeMap, "name")

			secretVolumes = append(secretVolumes, secretVolumeInfo{
				secretName: secretName,
				volumeName: volumeName,
			})
		}

		// Return the best matching secret
		return selectWebhookSecret(secretVolumes)
	}

	return ""
}

// secretVolumeInfo holds information about a secret volume.
type secretVolumeInfo struct {
	secretName string
	volumeName string
}

// selectWebhookSecret selects the most likely webhook certificate secret from a list.
//
// When a deployment has multiple secret volumes, this function uses keyword-based heuristics
// to identify which secret is most likely used for webhook certificates.
//
// Keyword Matching Strategy:
//   - Keywords: "webhook", "cert", "tls", "serving"
//   - Checks both secret name and volume name (case-insensitive)
//   - Returns the first secret matching any keyword
//
// Fallback: If no secrets match the keywords (rare), returns the first secret in the list.
// This is safe because most webhook deployments only have one secret volume.
//
// Why This Approach Works: Webhook certificate secrets are consistently named with
// keywords like "webhook-cert", "tls", or "serving-cert" across different operators.
// This heuristic is generic and works reliably across various OLM bundles.
func selectWebhookSecret(volumes []secretVolumeInfo) string {
	if len(volumes) == 0 {
		return ""
	}

	// Keywords that indicate a webhook certificate
	webhookKeywords := []string{"webhook", "cert", "tls", "serving"}

	// First pass: look for secrets with webhook-related names
	for _, vol := range volumes {
		lowerSecret := strings.ToLower(vol.secretName)
		lowerVolume := strings.ToLower(vol.volumeName)

		for _, keyword := range webhookKeywords {
			if strings.Contains(lowerSecret, keyword) || strings.Contains(lowerVolume, keyword) {
				return vol.secretName
			}
		}
	}

	// Fallback: return the first secret (most deployments only have one)
	return volumes[0].secretName
}

// hasCertificate checks if a certificate with the given name exists in the result.
func hasCertificate(objects []*unstructured.Unstructured, certName string) bool {
	for _, obj := range objects {
		if kube.IsKind(obj, gvks.Certificate) && obj.GetName() == certName {
			return true
		}
	}

	return false
}

// createCertificate creates a cert-manager Certificate resource.
func createCertificate(certName string, serviceName string, namespace string, secretName string, issuerName string, issuerKind string) (*unstructured.Unstructured, error) {
	cert := &certmanagerv1.Certificate{
		TypeMeta: metav1.TypeMeta{
			APIVersion: gvks.Certificate.GroupVersion().String(),
			Kind:       gvks.Certificate.Kind,
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      certName,
			Namespace: namespace,
		},
		Spec: certmanagerv1.CertificateSpec{
			SecretName: secretName,
			DNSNames: []string{
				serviceName + "." + namespace + ".svc",
				serviceName + "." + namespace + ".svc.cluster.local",
			},
			IssuerRef: cmmeta.ObjectReference{
				Kind: issuerKind,
				Name: issuerName,
			},
		},
	}

	u, err := kube.ToUnstructured(cert)
	if err != nil {
		return nil, fmt.Errorf("failed to convert certificate to unstructured: %w", err)
	}

	return u, nil
}
